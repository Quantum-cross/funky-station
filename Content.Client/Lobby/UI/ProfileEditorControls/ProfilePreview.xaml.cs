using System.Threading.Tasks;
using Content.Client.Sprite;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using TerraFX.Interop.Xlib;

namespace Content.Client.Lobby.UI.ProfileEditorControls;

[GenerateTypedNameReferences]
public sealed partial class ProfilePreview : BoxContainer
{
    private IEntityManager _entityManager = default!;

    private HumanoidProfileEditor? _editor;

    private Direction _previewRotation = Direction.North;

    public ProfilePreview()
    {
        RobustXamlLoader.Load(this);
        SpriteRotateLeft.OnPressed += OnRotateLeft;
        SpriteRotateRight.OnPressed += OnRotateRight;
    }

    /// <summary>
    /// This must be called before loading a profile to initialize the managers
    /// </summary>
    /// <param name="profileEditor"></param>
    /// <param name="entMan"></param>
    /// <param name="prefMan"></param>
    /// <param name="protoMan"></param>
    /// <param name="playerMan"></param>
    public void Initialize(HumanoidProfileEditor profileEditor, IEntityManager entMan, IClientPreferencesManager prefMan, IPrototypeManager protoMan, ISharedPlayerManager playerMan)
    {
        _editor = profileEditor;
        _entityManager = entMan;
        SpriteView.Initialize(prefMan, protoMan, playerMan);
    }

    private void OnRotateLeft(BaseButton.ButtonEventArgs obj)
    {
        _previewRotation = _previewRotation.TurnCw();
        SetPreviewRotation(_previewRotation);
    }

    private void OnRotateRight(BaseButton.ButtonEventArgs obj)
    {
        _previewRotation = _previewRotation.TurnCcw();
        SetPreviewRotation(_previewRotation);
    }

    private void SetPreviewRotation(Direction direction)
    {
        // I didn't write this code but it's pretty wacky...
        // It looks like OnRotateLeft/Right will increment or decrement the direction of _previewRotation, which includes
        // all 8 directions, but then this function basically truncates that to four directions, and multiplies by two
        // in order to get the sprite to rotate in 90 degree increments instead of 45 degree increments.
        // It's pretty wacky like I said but I'm not inclined to change code that works right now.
        SpriteView.OverrideDirection = (Direction) ((int) direction % 4 * 2);
    }

    /// <summary>
    /// Reloads the entire dummy entity for preview.
    /// </summary>
    /// <remarks>
    /// This is expensive so not recommended to run if you have a slider.
    /// </remarks>
    public void ReloadPreview()
    {
        if (_editor?.Profile == null)
            return;

        SpriteView.LoadPreview(_editor.Profile, _editor?.JobOverride, _editor?.ShouldShowClothes ?? true);
    }

    /// <summary>
    /// A slim reload that only updates the entity itself and not any of the job entities, etc.
    /// </summary>
    public void ReloadProfilePreview()
    {
        if (_editor?.Profile == null)
            return;

        SpriteView.ReloadProfilePreview(_editor.Profile);
    }

    public async void ExportImage(BaseButton? buttonToDisable = null)
    {
        var dir = SpriteView.OverrideDirection ?? Direction.South;

        var tasks = new List<Task>();

        // If we're given a button to momentarily disable for feedback, disable the button and add a delay task to
        // the list
        if(buttonToDisable is not null)
        {
            tasks.Add(Task.Delay(TimeSpan.FromSeconds(0.5f)));
            buttonToDisable.Disabled = true;
        }

        // Add the export task to the list
        tasks.Add(_entityManager.System<ContentSpriteSystem>().Export(SpriteView.PreviewDummy, dir, includeId: false));

        // Wait for the export task and the optional delay task
        await Task.WhenAll(tasks);

        // Now re-enable the button
        if(buttonToDisable is not null)
            buttonToDisable.Disabled = false;

    }
}
